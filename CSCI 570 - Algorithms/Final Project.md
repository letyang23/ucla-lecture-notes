### 2 Project Description

Implement the basic Dynamic Programming solution to the Sequence Alignment problem. Run the test set provided and show your results.

##### 2.1 Algorithm Description

Suppose we are given two strings $X$ and $Y$, where $X$ consists of the sequence of symbols $x_1,x_2,...,x_m$ and $Y$ consists of the sequence of symbols $y_1,y_2,...,y_n$.

Consider the sets $\{1,2,...,m\}$and $\{1,2,...,n\}$ as representing the different positions in the strings $X$ and $Y$, and consider a matching of these sets; Recall that a matching is a set of ordered pairs with the property that each item occurs in at most one pair. We say that a matching $M$ of these two sets is an alignment if there are no "crossing" pairs: if $(i,j),(i',j') ∈ M$ and $i<i'$, then $j <j'$. Intuitively, an alignment gives a way of lining up the two strings, by telling us which pairs of positions will be lined up with one another.

Our definition of similarity will be based on finding the optimal alignment between $X$ and $Y$, according to the following criteria. Suppose M is a given alignment between X and Y:

1. First, there is a parameter $δ_e >0$ that defines a gap penalty. For each position of $X$ or $Y$ that is not matched in $M$ – it is a gap – we incur a cost of $δ$.

2. Second, for each pair of letters $p,q$ in our alphabet, there is a mismatch cost of $\alpha_{pq}$ for lining up $p$ with $q$. Thus, for each $(i,j) ∈M$, we pay the appropriate mismatch cost $\alpha_{x_i,y_i}$ for lining up $x_i$ with $y_j$ . One generally assumes that $\alpha _{pp} = 0$ for each letter p - there is no mismatch cost to line up a letter with another copy of itself – although this will not be necessary in anything that follows.
3. The cost of $M$ is the sum of its gap and mismatch costs, and we seek an alignment of minimum cost.

##### 2.2 Input string Generator

The input to the program would be a text file containing the following information:

1. First base string ($s_1$)
2. Next $j$ lines consist of indices after which the copy of the previous string needs to be inserted in the cumulative string. (e.g., given below)
3. Second base string ($s_2$)
4. Next $k$ lines consist of indices after which the copy of the previous string needs to be inserted in the cumulative string. (e.g., given below)

This information would help generate 2 strings from the original 2 base strings. This file could be used as an input to your program, and your program could use the base strings and the rules to generate the actual strings. Also note that the numbers $j$ and $k$ correspond to the first and the second string, respectively. Make sure you validate the length of the first and the second string to be $2^j * len(s_1)$ and $2^k * len(s_2)$. Please note that the base strings need not be of equal length and similarly, $j$ need not be equal to $k$.

**Example:**

```
ACTG
3
6
1
TACG
1
2
9
```

Using the above numbers, the generated strings would be `ACACTGACTACTGACTGGTGACTACTGACTGG` and `TATTATACGCTATTATACGCGACGCGGACGCG`.

Following is the step by step process on how the above strings are generated:

ACTG

ACTG**ACTG**

ACTGACT**ACTGACTG**G

AC**ACTGACTACTGACTGG**TGACTACTGACTGG

TACG

TA**TACG**CG

TAT**TATACGCG**ACGCG

TATTATACGC**TATTATACGCGACGCG**GACGCG

##### 2.3 Values of Delta and Alphas

Values for $\alpha$'s are as follows. $\delta _ e$ is equal to 30.

|       | A    | C    | G    | T    |
| ----- | ---- | ---- | ---- | ---- |
| **A** | 0    | 110  | 48   | 94   |
| **C** | 110  | 0    | 118  | 48   |
| **G** | 48   | 118  | 0    | 110  |
| **T** | 94   | 48   | 110  | 0    |

##### 2.5 Bounds

1. Basic Algorithm
   - $0 \le j, k\le 10$
   - $1 \le len(s_1), len(s_2) \le 2000$
   - $1 \le 2^j * len(s_1), 2^k* len(s_2)\le 2000$

2. Memory Efficient Algorithm
   - $0 \le j, k\le 20$
   - $1 \le len(s_1), len(s_2) \le 20000$
   - $1 \le 2^j * len(s_1), 2^k* len(s_2)\le 20000$

##### 3.1

Your program should take 2 arguments:

1. Input file path
2. Output file path (If path is valid and file not found, your program should create it)

Examples:

`python3 basic_3.py input.txt output.txt`

##### 3.2

Implement the Dynamic Programming algorithm. Your program should print the following information at the respective lines in the output file:

1. Cost of the alignment (Integer)
2. First string alignment ( Consists of A, C, T, G, _ (gap) characters)
3. Second string alignment ( Consists of A, C, T, G, _ (gap) characters)
4. Time in Milliseconds (Float)
5. Memory in Kilobytes (Float)

Note: There can be multiple alignments that have the same cost. You can print ANY alignment generated by your program. The only condition is it should have a minimum cost.

e.g. For strings $s_1$: A and $s_2$: C, alignments `A_ , _C` and `_A, C_`both have alignment cost 60 which is minimum. You can print any one of them.

##### 3.3

Implement the memory-efficient version of this solution and repeat the tests in 3.2.

##### Sample Code for memory and time calculation

```python
import sys
from resource import *
import time
import psutil

def process_memory():
    process = psutil.Process()
    memory_info = process.memory_info()
    memory_consumed = int(memory_info.rss / 1024)
    return memory_consumed

def time_wrapper():
    start_time = time.time()
    call_algorithm()    # replace with your algorithm function call
    end_time = time.time()
    time_taken = (end_time - start_time) * 1000
    return time_taken
```



##### Sample Input file:

```
ACTG
3
6
1
1
TACG
1
2
9
2
```

Sample Output file:

```
1296
_A_CA_CACT__G__A_C_TAC_TGACTG_GTGA__C_TACTGACTGGACTGACTACTGACTGGTGACTACT_GACTG_G
TATTATTA_TACGCTATTATACGCGAC_GCG_GACGCGTA_T_AC__G_CT_ATTA_T_AC__GCGAC_GC_GGAC_GCG
3.720998764038086
54880
```

